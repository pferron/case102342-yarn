"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* eslint-disable no-await-in-loop */
const core_1 = require("@auto-it/core");
const bot_list_1 = tslib_1.__importDefault(require("@auto-it/bot-list"));
const array_prototype_flatmap_1 = tslib_1.__importDefault(require("array.prototype.flatmap"));
const endent_1 = tslib_1.__importDefault(require("endent"));
const url_join_1 = tslib_1.__importDefault(require("url-join"));
const url_1 = require("url");
/**
 * Thank first time contributors for their work right in your release notes.
 */
class FirstTimeContributorPlugin {
    constructor() {
        /** The name of the plugin */
        this.name = "first-time-contributor";
    }
    /** Tap into auto plugin points. */
    apply(auto) {
        auto.hooks.onCreateChangelog.tap(this.name, (changelog) => {
            const base = new url_1.URL(changelog.options.baseUrl).origin;
            /** Format a string for the contributor */
            const renderContributor = ({ name, username }) => {
                const link = `[@${username}](${url_join_1.default(base, username || "")})`;
                return `${name}${username ? (name ? ` (${link})` : link) : ""}`;
            };
            changelog.hooks.addToBody.tapPromise(this.name, async (notes, commits) => {
                var _a, _b, _c, _d;
                const newContributors = [];
                for (const author of array_prototype_flatmap_1.default(commits, (c) => c.authors)) {
                    if (!author.username ||
                        author.type === "Bot" ||
                        bot_list_1.default.includes(author.username) ||
                        (author.name && bot_list_1.default.includes(author.name))) {
                        continue;
                    }
                    const user = await ((_a = auto.git) === null || _a === void 0 ? void 0 : _a.getUserByUsername(author.username));
                    if (!user) {
                        continue;
                    }
                    // prettier-ignore
                    const userCommits = await ((_b = auto.git) === null || _b === void 0 ? void 0 : _b.graphql(`
              {
                repository(name: "${(_c = auto.git) === null || _c === void 0 ? void 0 : _c.options.repo}", owner: "${(_d = auto.git) === null || _d === void 0 ? void 0 : _d.options.owner}") {
                  object(expression: "${core_1.getCurrentBranch()}") {
                    ... on Commit {
                      history(after: "${commits[commits.length - 1].hash} 0", first: 1, author: { id: "${user.node_id}" }) {
                        edges {
                          node {
                            message
                          }
                        }
                      }
                    }
                  }
                }
              }
            `));
                    if (userCommits &&
                        userCommits.repository.object.history.edges.length === 0) {
                        newContributors.push(author);
                    }
                }
                if (!newContributors.length) {
                    return notes;
                }
                const lines = new Set(newContributors.map(renderContributor));
                let thankYou;
                if (lines.size > 1) {
                    thankYou = endent_1.default `
              :tada: This release contains work from new contributors! :tada:

              Thanks for all your work!\n\n${[...lines]
                        .map((line) => `:heart: ${line}`)
                        .join("\n\n")}
            `;
                }
                else {
                    thankYou = endent_1.default `
              :tada: This release contains work from a new contributor! :tada:

              Thank you, ${[...lines][0]}, for all your work!
            `;
                }
                return [...notes, thankYou];
            });
        });
    }
}
exports.default = FirstTimeContributorPlugin;
//# sourceMappingURL=index.js.map