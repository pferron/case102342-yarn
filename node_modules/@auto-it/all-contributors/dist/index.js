"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@auto-it/core");
const env_ci_1 = tslib_1.__importDefault(require("env-ci"));
const endent_1 = tslib_1.__importDefault(require("endent"));
const bot_list_1 = tslib_1.__importDefault(require("@auto-it/bot-list"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const anymatch_1 = tslib_1.__importDefault(require("anymatch"));
const await_to_js_1 = tslib_1.__importDefault(require("await-to-js"));
const t = tslib_1.__importStar(require("io-ts"));
const fromentries_1 = tslib_1.__importDefault(require("fromentries"));
const contributors_1 = tslib_1.__importDefault(require("all-contributors-cli/dist/contributors"));
const generate_1 = tslib_1.__importDefault(require("all-contributors-cli/dist/generate"));
const contributionTypes = [
    "blog",
    "bug",
    "business",
    "code",
    "content",
    "data",
    "design",
    "doc",
    "eventOrganizing",
    "example",
    "financial",
    "fundingFinding",
    "ideas",
    "infra",
    "maintenance",
    "platform",
    "plugin",
    "projectManagement",
    "question",
    "review",
    "security",
    "talk",
    "test",
    "tool",
    "translation",
    "tutorial",
    "userTesting",
    "video",
];
/** Determine if it's a valid contribution type */
const isContribution = (contribution) => contributionTypes.includes(contribution);
/** Get an rc file if there is one. */
function getRcFile(auto) {
    const rcFile = path_1.default.join(process.cwd(), ".all-contributorsrc");
    if (!fs_1.default.existsSync(rcFile)) {
        auto.logger.verbose.warn(`No all-contributors configuration file found at: ${rcFile}`);
        return;
    }
    try {
        const config = JSON.parse(fs_1.default.readFileSync(rcFile, "utf8"));
        return Object.assign(Object.assign({}, config), { config: rcFile });
    }
    catch (error) {
        auto.logger.log.error(`Encountered errors loading all-contributors configuration at ${rcFile}`, error);
        process.exit(1);
    }
}
const pattern = t.union([t.string, t.array(t.string)]);
const pluginOptions = t.partial({
    /** Usernames to exclude from the contributors */
    exclude: t.array(t.string),
    /** Globs to detect change types by */
    types: t.partial(fromentries_1.default(contributionTypes.map((c) => [c, pattern]))),
});
const defaultOptions = {
    exclude: bot_list_1.default,
    types: {
        doc: ["**/*.mdx", "**/*.md", "**/docs/**/*", "**/documentation/**/*"],
        example: ["**/*.stories*", "**/*.story.*"],
        infra: ["**/.circle/**/*", "**/.github/**/*", "**/travis.yml"],
        test: ["**/*.test.*", "**/test/**", "**/__tests__/**"],
        code: ["**/src/**/*", "**/lib/**/*", "**/package.json", "**/tsconfig.json"],
    },
};
const title = /[#]{0,5}[ ]*[C|c]ontributions/;
const contributorLine = /^[-*] @(\S+)\s+[:-]\s+([\S ,]+)$/;
/** Find contributions listed in PR bodies */
function getExtraContributors(body) {
    const authorContributions = {};
    if (!body) {
        return;
    }
    const start = body.match(title);
    if (!start) {
        return;
    }
    body
        .slice((start.index || 0) + (start[0] || "").length)
        .replace(/\r\n/g, "\n")
        .split("\n")
        .forEach((line) => {
        if (line.startsWith("#") || line.startsWith("<!--")) {
            return;
        }
        const contributor = line.match(contributorLine);
        if (!contributor) {
            return;
        }
        const [, username, contributions] = contributor;
        if (!authorContributions[username]) {
            authorContributions[username] = new Set();
        }
        contributions
            .split(",")
            .map((contribution) => contribution.trim())
            .forEach((contribution) => authorContributions[username].add(contribution));
    });
    return authorContributions;
}
/** Determine which files need to display contributors and generate contributors */
function generateContributorReadme(config, contributors) {
    return Promise.all((config.files || ["README.md"]).map(async (file) => {
        const oldReadMe = fs_1.default.readFileSync(file, {
            encoding: "utf-8",
        });
        const newReadMe = await generate_1.default(Object.assign(Object.assign({ contributorsPerLine: 7, imageSize: 100 }, config), { contributors }), contributors, oldReadMe);
        fs_1.default.writeFileSync(file, newReadMe);
    }));
}
/** Automatically add contributors as changelogs are produced. */
class AllContributorsPlugin {
    /** Initialize the plugin with it's options */
    constructor(options = {}) {
        /** The name of the plugin */
        this.name = "all-contributors";
        this.options = {
            exclude: [...(defaultOptions.exclude || []), ...(options.exclude || [])],
            types: Object.assign(Object.assign({}, defaultOptions.types), options.types),
        };
        this.generatedReadme = false;
    }
    /** Tap into auto plugin points. */
    apply(auto) {
        const env = env_ci_1.default();
        auto.hooks.validateConfig.tapPromise(this.name, async (name, options) => {
            if (name === this.name || name === `@auto-it/${this.name}`) {
                return core_1.validatePluginConfiguration(this.name, pluginOptions, options);
            }
        });
        auto.hooks.beforeShipIt.tapPromise(this.name, async (context) => {
            var _a;
            if (context.releaseType === "latest" ||
                context.releaseType === "old" ||
                !("pr" in env)) {
                return;
            }
            const pr = Number(env.pr);
            if (!pr) {
                return;
            }
            const prInfo = await ((_a = auto.git) === null || _a === void 0 ? void 0 : _a.getPullRequest(pr));
            auto.logger.log.info(this.name, { prInfo });
            if (!prInfo) {
                return;
            }
            const extra = getExtraContributors(prInfo.data.body);
            auto.logger.log.info(this.name, { extra });
            if (!extra || !Object.keys(extra).length) {
                return;
            }
            const allContributions = Object.values(extra).reduce((all, i) => [...all, ...i], []);
            const unknownTypes = allContributions.filter((contribution) => !contributionTypes.includes(contribution));
            const hasValidTypes = allContributions.length !== unknownTypes.length;
            const message = endent_1.default `
        # Extra Contributions

        ${hasValidTypes
                ? endent_1.default `
              The following contributions will be added to all-contributors (as well as any code contributions) when this PR is released :tada::

              ${Object.entries(extra)
                    .map(([username, contributions]) => {
                    const validContributions = [...contributions].filter(isContribution);
                    if (!validContributions.length) {
                        return "";
                    }
                    return `- @${username} - ${validContributions.join(", ")}`;
                })
                    .filter(Boolean)
                    .join("\n")}
            `
                : "No valid contribution types found!"}

        ${unknownTypes.length
                ? endent_1.default `
                ## Unknown Contribution Types

                We found some unknown contribution types in your PR body!
                These contributions will not be counted and you should fix them.

                ${unknownTypes.map((type) => `- \`${type}\``)}
              `
                : ""}
      `;
            await auto.comment({
                pr,
                context: "Extra Contributions",
                edit: true,
                message,
            });
        });
        auto.hooks.afterChangelog.tapPromise(this.name, async ({ commits }) => {
            const rootDir = process.cwd();
            // Always do the root package
            let packages = [{ path: rootDir, name: "root-package" }];
            try {
                // Try to get sub-packages
                packages = [...packages, ...(await core_1.getLernaPackages())];
            }
            catch (error) { }
            // Go through each package and update code contributions
            await packages.reduce(async (last, { name, path }) => {
                // Cannot run git operations in parallel
                await last;
                auto.logger.verbose.info(`Updating contributors for: ${name}`);
                const includedCommits = commits.filter((commit) => commit.files.some((file) => core_1.inFolder(path, file)));
                if (includedCommits.length > 0) {
                    auto.logger.verbose.success(`${name} has ${includedCommits.length} new commits.`);
                    auto.logger.veryVerbose.info(`With commits: ${JSON.stringify(includedCommits, null, 2)}`);
                    process.chdir(path);
                    await this.updateContributors(auto, includedCommits);
                }
            }, Promise.resolve());
            process.chdir(rootDir);
            const changedFiles = await core_1.execPromise("git", ["status", "--porcelain"]);
            if (changedFiles) {
                await core_1.execPromise("git", ["add", "README.md"]);
                await core_1.execPromise("git", ["add", ".all-contributorsrc"]);
                await await_to_js_1.default(core_1.execPromise("git", ["add", "**/README.md"]));
                await await_to_js_1.default(core_1.execPromise("git", ["add", "**/.all-contributorsrc"]));
                await core_1.execPromise("git", [
                    "commit",
                    "--no-verify",
                    "-m",
                    '"Update contributors [skip ci]"',
                ]);
            }
        });
        auto.hooks.onCreateLogParse.tap(this.name, (logParse) => {
            logParse.hooks.parseCommit.tapPromise(this.name, async (commit) => {
                const extraContributions = getExtraContributors(commit.rawBody);
                if (!extraContributions) {
                    return commit;
                }
                const contributors = (await Promise.all(Object.keys(extraContributions).map(async (contributor) => { var _a; return (_a = auto.git) === null || _a === void 0 ? void 0 : _a.getUserByUsername(contributor); }))).filter((c) => Boolean(c));
                return Object.assign(Object.assign({}, commit), { authors: [
                        ...commit.authors,
                        ...contributors.map((c) => (Object.assign(Object.assign({}, c), { username: c.login }))),
                    ] });
            });
        });
    }
    /** Update the contributors rc for a package. */
    async updateContributors(auto, commits) {
        var e_1, _a;
        const config = getRcFile(auto);
        if (!config) {
            return;
        }
        const authorContributions = {};
        let didUpdate = false;
        const commitsWithAllChangedFiles = await Promise.all(commits.map(async (commit) => {
            const extra = await core_1.execPromise("git", [
                "show",
                '--pretty=""',
                "--name-only",
                "--first-parent",
                "-m",
                commit.hash,
                "-l0",
            ]);
            commit.files = [...new Set([...commit.files, ...extra.split("\n")])];
            return commit;
        }));
        // 1. Find all the authors and their contribution types
        commitsWithAllChangedFiles.forEach((commit) => {
            const { authors } = commit;
            let { files } = commit;
            // Find automated contribution for type globs
            Object.keys(this.options.types || {})
                .filter((type) => {
                /** Determine if path is the contribution type */
                const isType = (file) => anymatch_1.default(this.options.types[type] || [], file);
                const isMatch = files.some(isType);
                files = files.filter((file) => !isType(file));
                return isMatch;
            })
                .forEach((contribution) => {
                authors.forEach(({ username }) => {
                    if (!username) {
                        return;
                    }
                    if (!authorContributions[username]) {
                        authorContributions[username] = new Set();
                    }
                    authorContributions[username].add(contribution);
                });
            });
            // Find contributions listed in PR bodies
            const extra = getExtraContributors(commit.rawBody);
            if (extra) {
                Object.entries(extra).forEach(([username, contributions]) => {
                    if (!authorContributions[username]) {
                        authorContributions[username] = new Set();
                    }
                    [...contributions]
                        .filter(isContribution)
                        .forEach((contribution) => authorContributions[username].add(contribution));
                });
            }
        });
        auto.logger.verbose.info("Found contributions:", authorContributions);
        try {
            // 2. Determine if contributor has update
            for (var _b = tslib_1.__asyncValues(Object.entries(authorContributions)), _c; _c = await _b.next(), !_c.done;) {
                const [username, contributions] = _c.value;
                const { contributions: old = [] } = config.contributors.find((contributor) => contributor.login.toLowerCase() === username.toLowerCase()) || {};
                const hasNew = [...contributions].find((contribution) => !old.includes(contribution));
                if (hasNew && !this.options.exclude.includes(username)) {
                    const newContributions = new Set([...old, ...contributions]);
                    didUpdate = true;
                    auto.logger.log.info(`Adding "${username}"'s contributions...`);
                    // If a PRIVATE_TOKEN is not set for all-contributors-cli
                    // use the GH_TOKEN
                    if (process.env.PRIVATE_TOKEN === undefined) {
                        process.env.PRIVATE_TOKEN = process.env.GH_TOKEN;
                    }
                    // Update/add contributor in RC file
                    const { contributors } = await contributors_1.default(config, username, Array.from(newContributions).join(","));
                    this.generatedReadme = true;
                    // Update files that contain contributors table
                    await generateContributorReadme(config, contributors);
                }
                else {
                    auto.logger.verbose.warn(`"${username}" had no new contributions...`);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (config.contributors.length && !this.generatedReadme) {
            // if the all-contributors has not been generated ... generate it
            try {
                // test if the first file in the list of files has been init
                const file = path_1.default.join(process.cwd(), config.files ? config.files[0] : "README.md");
                const displayFile = file ? fs_1.default.readFileSync(file, "utf8") : "";
                const notInitalized = displayFile.indexOf("<!-- markdownlint-disable -->\n<!-- markdownlint-restore -->");
                if (notInitalized && file) {
                    await generateContributorReadme(config, config.contributors);
                }
            }
            catch (_d) { }
        }
        if (didUpdate) {
            auto.logger.log.success("Updated contributors!");
        }
    }
}
exports.default = AllContributorsPlugin;
//# sourceMappingURL=index.js.map