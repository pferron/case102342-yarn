"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const conventional_commits_parser_1 = require("conventional-commits-parser");
const util_1 = require("util");
const conventional_changelog_preset_loader_1 = tslib_1.__importDefault(require("conventional-changelog-preset-loader"));
const array_prototype_flatmap_1 = tslib_1.__importDefault(require("array.prototype.flatmap"));
const t = tslib_1.__importStar(require("io-ts"));
const core_1 = require("@auto-it/core");
const endent_1 = tslib_1.__importDefault(require("endent"));
/** Resolve a conventional commit preset */
function presetResolver(presetPackage) {
    if (typeof presetPackage === "function") {
        return util_1.promisify(presetPackage)();
    }
    // handle object literal or Promise instance
    if (typeof presetPackage === "object") {
        return presetPackage;
    }
    throw new Error("preset package must be a promise, function, or object");
}
const defaultPreset = {
    recommendedBumpOpts: {
        parserOpts: {
            headerPattern: /^(\w*)(?:\((.*)\))?!?: (.*)$/,
            breakingHeaderPattern: /^(\w*)(?:\((.*)\))?!: (.*)$/,
            headerCorrespondence: ["type", "scope", "subject"],
            noteKeywords: ["BREAKING CHANGE"],
        },
        /** Find the bump */
        whatBump: (commits) => {
            let level;
            let breakings = 0;
            let features = 0;
            commits.forEach((commit) => {
                var _a;
                if (commit.notes.length > 0 ||
                    commit.type === "BREAKING" ||
                    ((_a = commit.header) === null || _a === void 0 ? void 0 : _a.match(defaultPreset.recommendedBumpOpts.parserOpts.breakingHeaderPattern))) {
                    breakings += commit.notes.length;
                    level = 0;
                }
                else if (commit.type === "feat") {
                    features += 1;
                    if (level === undefined) {
                        level = 1;
                    }
                }
                else if (commit.type === "fix" && level === undefined) {
                    level = 2;
                }
                else if (commit.type && level === undefined) {
                    level = 3;
                }
            });
            return {
                level: level,
                reason: breakings === 1
                    ? `There is ${breakings} BREAKING CHANGE and ${features} features`
                    : `There are ${breakings} BREAKING CHANGES and ${features} features`,
            };
        },
    },
};
const optionalOptions = t.partial({
    /** A path to the formula template */
    preset: t.string,
    /** The default release type to apply when the conventional commit isn't "fix", "feat" or "breaking" */
    defaultReleaseType: t.string,
});
const VERSIONS = [core_1.SEMVER.major, core_1.SEMVER.minor, core_1.SEMVER.patch];
/**
 * Parse conventional commit messages and use them to
 * calculate the version.
 */
class ConventionalCommitsPlugin {
    /** Initialize the plugin with it's options */
    constructor(options = {}) {
        /** The name of the plugin */
        this.name = "conventional-commits";
        this.options = Object.assign({ defaultReleaseType: "skip" }, options);
    }
    /** Tap into auto plugin points. */
    apply(auto) {
        /** Get the bump using conventional commits */
        const getBump = async (message) => {
            if (!this.storedGetBump) {
                /** Load the implementation */
                this.storedGetBump = async (message) => {
                    var _a;
                    if (!auto.semVerLabels) {
                        return;
                    }
                    const conventionalCommit = conventional_commits_parser_1.sync(message);
                    const preset = this.options.preset
                        ? await conventional_changelog_preset_loader_1.default(this.options.preset)
                        : defaultPreset;
                    const config = await presetResolver(preset);
                    const whatBump = ((_a = config.recommendedBumpOpts) === null || _a === void 0 ? void 0 : _a.whatBump) ||
                        defaultPreset.recommendedBumpOpts.whatBump;
                    const result = whatBump([conventionalCommit]);
                    if ((result === null || result === void 0 ? void 0 : result.level) !== null && (result === null || result === void 0 ? void 0 : result.level) !== undefined) {
                        const bump = VERSIONS[result.level] || this.options.defaultReleaseType;
                        return bump;
                    }
                };
            }
            return this.storedGetBump(message);
        };
        auto.hooks.prCheck.tapPromise(this.name, async ({ pr }) => {
            var _a, _b;
            if (!auto.git) {
                return;
            }
            const labels = await auto.git.getLabels(pr.number);
            const semVerLabels = array_prototype_flatmap_1.default([...auto.semVerLabels.values()], (x) => x);
            // check if semver label is already on PR
            if (labels.some((l) => semVerLabels.includes(l))) {
                return;
            }
            const commits = await ((_a = auto.git) === null || _a === void 0 ? void 0 : _a.getCommitsForPR(pr.number));
            const bumps = await Promise.all(commits.map(async (commit) => {
                try {
                    return await getBump(commit.commit.message);
                }
                catch (error) {
                    auto.logger.verbose.info(`No conventional commit message found for ${commit.sha}`);
                }
            }));
            const definedBumps = bumps.filter((bump) => bump !== undefined);
            if (definedBumps.length === 0) {
                return;
            }
            const bump = definedBumps
                .map(core_1.getReleaseType)
                .reduce(core_1.getHigherSemverTag, core_1.SEMVER.noVersion);
            if (bump === undefined ||
                bump === null ||
                bump === core_1.SEMVER.premajor ||
                bump === core_1.SEMVER.preminor ||
                bump === core_1.SEMVER.prepatch) {
                return;
            }
            const bumpOrSkip = bump === core_1.SEMVER.noVersion ? 'skip' : bump;
            const label = (_b = auto.semVerLabels) === null || _b === void 0 ? void 0 : _b.get(bumpOrSkip);
            if (label) {
                await auto.git.addLabelToPr(pr.number, label[0]);
            }
        });
        auto.hooks.onCreateLogParse.tap(this.name, (logParse) => {
            logParse.hooks.parseCommit.tapPromise(this.name, async (commit) => {
                if (!auto.semVerLabels || !auto.git) {
                    return commit;
                }
                try {
                    const message = `${commit.subject}\n\n${commit.rawBody}`;
                    const allSemVerLabels = [
                        auto.semVerLabels.get(core_1.SEMVER.major),
                        auto.semVerLabels.get(core_1.SEMVER.minor),
                        auto.semVerLabels.get(core_1.SEMVER.patch),
                    ].reduce((acc, labels) => (labels ? [...acc, ...labels] : acc), []);
                    const prHasSemverLabel = commit.labels.some((l) => allSemVerLabels.includes(l));
                    let bump = await getBump(message);
                    // Take into account all conventional commit message in each commit for a PR
                    if (commit.pullRequest &&
                        // If the PR already has a semver label it takes precedence over conventional
                        // commit messages
                        !prHasSemverLabel) {
                        const prCommits = await auto.git.getCommitsForPR(commit.pullRequest.number);
                        const prBumps = (await Promise.all(prCommits.map((c) => getBump(c.commit.message)))).filter((bump) => Boolean(bump && bump !== "skip"));
                        if (prBumps.includes(core_1.SEMVER.major)) {
                            bump = core_1.SEMVER.major;
                        }
                        else if (prBumps.includes(core_1.SEMVER.minor)) {
                            bump = core_1.SEMVER.minor;
                        }
                        else if (prBumps.includes(core_1.SEMVER.patch)) {
                            bump = core_1.SEMVER.patch;
                        }
                    }
                    if (!bump) {
                        return commit;
                    }
                    const incrementLabel = auto.semVerLabels.get(bump);
                    if (incrementLabel && !prHasSemverLabel) {
                        auto.logger.verbose.log(endent_1.default `
                Found "${bump}" from conventional commit message: ${message}
              
                Applying "${incrementLabel}"
              `);
                        commit.labels = [...commit.labels, incrementLabel[0]];
                    }
                }
                catch (error) {
                    auto.logger.verbose.info(`No conventional commit message found for ${commit.hash}`);
                }
                return commit;
            });
            // should omit PR commit if there exists a commit with a CC commit message
            logParse.hooks.omitCommit.tapPromise(this.name, async (commit) => {
                if (auto.git &&
                    auto.release &&
                    commit.pullRequest &&
                    commit.labels.length === 0) {
                    const prCommits = await auto.git.getCommitsForPR(commit.pullRequest.number);
                    let shouldOmit = false;
                    // Omit the commit if one of the commits in the PR contains a CC message since it will already be counted
                    await Promise.all(prCommits.map(async (c) => {
                        try {
                            const label = await getBump(c.commit.message);
                            if (label) {
                                shouldOmit = true;
                            }
                        }
                        catch (error) { }
                    }));
                    return shouldOmit;
                }
            });
        });
    }
}
exports.default = ConventionalCommitsPlugin;
//# sourceMappingURL=index.js.map